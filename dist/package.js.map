{"version":3,"file":"package.js","sources":["../src/package.js"],"names":["scope","Packer","parseSetup","setup","container","allItems","id","currentContainer","sNo","Object","defineProperty","value","writable","sLen","items","length","itemSetup","getMinimumPriority","arr","min","i","ilen","priority","Package","this","direction","gutter","root","prototype","packItems","that","packer","sorter","sort","map","hidden","rect","Rectangle","width","precalculateWidth","indexOf","parseFloat","height","precalculateHeight","add","minHeight","minWidth","reprioritizeItem","item","increase","end","higher","lower","collection","RangeError","sortedIndex","resizeItem","moveToContainer","what","where","noPacking","from","to","whereInWhat","isInContainer","oldWhatContainer","splice","push","deleteContainer","noRepacking","undefined","siblingsList","itemNo","removed","generatePackageName","createNewContainer","inContainer","rectangle","siblings","c","window"],"mappings":"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","sourcesContent":["/**\n * Package\n * version: 1.3.1\n */\n(function( scope, Packer ){\n\"use strict\";\n\n/**\n * Extend JSON setup, with circular references to items' containers.\n * Creates an array of all items and virtual containers,\n * that maps to nodes in setup tree.\n * Applies default container id.\n * @param {Object} setup packer setup\n * @param {Item} [container] parent node\n * @param {Object} [allItems={}] map of items to update\n * @returns {Array} array of updated/created items\n */\nfunction parseSetup( setup, container, allItems ){\n    allItems = allItems || {};\n    var id, currentContainer;\n    if( !container ){\n      id = setup.id = \"root\";\n      container = null;\n    } else {\n      id = setup.id || ( (container && container.id) + \"_\" + sNo );\n      // FIXME i'm ugly\n      setup.id = id;\n    }\n    // create item for current container\n    allItems[ id ] = currentContainer = setup;\n    Object.defineProperty(setup, \"container\", {value: container, writable: true});\n\n    // create allItems list\n    for(var sNo = 0, sLen = setup.items.length; sNo < sLen; sNo++) {\n      var itemSetup = setup.items[sNo];\n\n      // walk the tree recursively\n      if(itemSetup.items){\n        // FIXME I'm ugly\n        // create default id\n        if(!itemSetup.id){\n          itemSetup.id = ( currentContainer.id + \"_\" + sNo );\n        }\n        parseSetup( itemSetup, currentContainer, allItems );\n      } else {\n        // TODO: make index/id not mandatory (tomalec)\n        allItems[ itemSetup.id ] = itemSetup;\n        Object.defineProperty(itemSetup, \"container\", {value: currentContainer, writable: true });\n      }\n    }\n    return allItems;\n}\n /**\n * Returns the minimum value of the priority property from the given array of objects\n * @param {Array<Object>} arr\n * @return {Number} number in range from 0 to 1\n * @TODO DRY\n */\nfunction getMinimumPriority(arr) {\n  var min = 1;\n  for (var i = 0, ilen = arr.length; i < ilen; i++) {\n    if (arr[i].priority < min) {\n      min = arr[i].priority;\n    }\n  }\n  if (min < 0) {\n    min = 0;\n  }\n  return min;\n}\n\n/**\n * [Package description]\n * @param {Object} [setup] packer setup (*Warning*: object will be modified!)\n * @IDEA remove this.items (tomalec)\n */\nfunction Package( setup ){\n  if(setup){\n    this.setup = setup;\n    // XXX: this is used only by layer above (juicy-tile-list to match with elements)\n    this.allItems = parseSetup( setup );\n  }else{\n    this.setup = {\n      id: \"root\",\n      direction: \"horizontal\",\n      gutter: 0,\n      items: []\n    };\n    this.allItems = {root: this.setup};\n  }\n}\nPackage.prototype.allItems = null;\nPackage.prototype.setup = null;\n\n\nPackage.prototype.direction = \"horizontal\";\n\n/**\n * [packItems description]\n * @param {Object} setup setup of items fo pack, if not give `#setup` will be used\n */\nPackage.prototype.packItems = function packItems( setup ) {\n  setup || (setup = this.setup);\n  var that = this,\n      packer = new Packer(setup),\n      gutter = setup.gutter || 0;\n\n  //pack rectangles, and calculate container size\n  packer.items = (this.sorter ? setup.items.sort(this.sorter) : setup.items) // sort- if neded\n    .map(function(itemSetup){\n      if(itemSetup.hidden){\n        return itemSetup;\n      }\n      // TODO: do it more lightweight\n      var rect = new Rectangle(itemSetup);\n\n      //first calculate rect width because it cannot be auto TODO: fix for vertical mode\n      if( !rect.precalculateWidth && typeof rect.width == \"string\" && rect.width.indexOf(\"%\") > 0 ){\n        rect.width = ( (setup.width + gutter) * parseFloat(rect.width) /100  - gutter);\n      } else {\n        rect.width = parseFloat( rect.width );\n      }\n      // caluclate relative size\n      // we cannot use calc(xx% - gutter px) as it can be in virtual container which is a sibling\n      if( !rect.precalculateHeight && typeof rect.height == \"string\" && rect.height.indexOf(\"%\") > 0 ){\n        rect.height = ( (setup.height + gutter) * parseFloat(rect.height) /100 - gutter );\n      } else {\n        rect.height = parseFloat( rect.height );\n      }\n\n\n      if (itemSetup.items ) { // container\n        // pack its items first, to figureout minSize\n        rect = that.packItems(\n          rect // use caculated width and height\n        );\n\n      }\n\n      // Pack item\n      packer.add(rect);\n\n      return rect;\n  });\n\n  //change Infinity back to real size:\n  packer.height = setup.precalculateHeight ? packer.minHeight : parseFloat( setup.height );\n  packer.width = setup.precalculateWidth ? packer.minWidth : parseFloat( setup.width );\n  return packer;\n};\n\n\n/**\n * Change priority of given item\n * @//param  {Item | Number | String} itemIndex    item/container id (by default the original item index in DOM), or item itself\n * @param  {Item} item    item to be re-prioritized\n * @param  {Boolean} increase  true - increases priority, false - decreases\n * @param  {Boolean} [end=false] true to move to the end\n * @return {juicy-tile-list}        self\n * @TODO write tests\n */\nPackage.prototype.reprioritizeItem =  function( item, increase, end ){\n  var higher, lower, item;\n  // if( typeof item !== 'object'){\n  //   item = this.items[item];\n  // }\n  var itemSetup = item;\n  // use parent items\n  var collection = item.container && item.container.items;\n  // do nothing for root\n  if( !collection ){\n    throw new RangeError( \"Cannot reprioritize root container\");\n    return false;\n  }\n  // do nothing if there is nothing to rearrange\n  if( collection.length < 2){\n    return this;\n  }\n  var sortedIndex = collection.indexOf( itemSetup );\n\n  // move to the end\n  if( end ||\n      increase && (sortedIndex <= 1) ||\n      !increase && (sortedIndex >= collection.length - 2 )\n  ){\n      // top\n      if(increase){\n          // already on top\n          if(itemSetup.priority == 1){\n              return this;\n          }\n          higher = collection[0];\n          // already there, but with different priority\n          if(higher == item){\n              itemSetup.priority = 1;\n              // do not rearrange\n              return this;\n          } else {\n              // move to the middle\n              higher.priority = (collection[1].priority + 1)/2;\n              itemSetup.priority = 1;\n          }\n      } else { // bottom\n          // already at the bottom\n          if(itemSetup.priority == 0){\n              return this;\n          }\n          lower = collection[collection.length -1 ];\n          // already there, but with different priority.\n          if(lower == item){\n              itemSetup.priority = 0;\n              return this;\n          } else {\n              // move to the middle\n              lower.priority = collection[collection.length -2].priority/2;\n              itemSetup.priority = 0;\n          }\n\n      }\n  } else {\n      // top\n      if(increase){\n          higher = collection[sortedIndex-2];\n          lower = collection[sortedIndex-1];\n      } else {\n          higher = collection[sortedIndex+1];\n          lower = collection[sortedIndex+2];\n      }\n      itemSetup.priority = (higher.priority + lower.priority)/2;\n  }\n\n  // TODO only this scope\n  this.packItems( );\n  return this;\n};\n\n/**\n * Resize given item.\n * @//param  {SetupItemRef} item   item from list, or item id (by default the original item index in DOM)\n * @param  {SetupItemRef} item   item from list\n * @param  {Number} width  number of cells/columns\n * @param  {Number} height number of cells/rows\n * @return {juicy-tile-list}        self\n */\nPackage.prototype.resizeItem = function(item, width, height){\n  // if(typeof item !== 'object'){\n  //     item = this.items[item];\n  // }\n  item.width = width;\n  item.height = height;\n  // re-pack only applicable branch\n  // this.packItems( item.container, item.container.packer );\n  // re-pack everthing\n  this.packItems();\n\n  return this;\n};\n/**\n *\n * @//param  {SetupItemRef | String} what item reference or id\n * @param  {SetupItemRef} what item reference\n * @//param  {SetupItemRef} [where]    Reference to, or id of destination container.    If id given in *string* is not found in existing containers list, new one will be created and wrapped around given item.\n * @param  {SetupItemRef} [where]    Reference to destination container.\n * @param {Boolean} [noPacking=false]\n * @return {[type]}              [description]\n */\nPackage.prototype.moveToContainer = function( what, where, noPacking ){\n  // if( typeof what !== \"object\" ){\n  //   what = this.items[what];\n  // }\n  var from = what.container && what.container.items;\n  // do nothing for root\n  if( !from ){\n    throw new RangeError( \"Cannot move root container\");\n    return false;\n  }\n  var to;\n  // if( typeof where === \"string\" ){\n  //   // container given by key\n  //   where = this.items[where] ||\n  //   // or new one\n  //           this.createNewContainer(where, from, what, true);\n  // }\n  to = where.items;\n  // origin == destination\n  if( from == to ){\n    return false;\n  }\n\n  var whereInWhat = this.isInContainer(what, where);\n  var oldWhatContainer = what.container;\n\n  from.splice( from.indexOf(what), 1);\n  what.container = where;\n  to.push(what);\n\n  if(!noPacking){\n    //TODO: repack only applicable ones\n    this.packItems();\n  }\n\n  if (whereInWhat) {\n      this.moveToContainer(where, oldWhatContainer, noPacking);\n  }\n};\n/**\n * Delete virtual container, move items (if any) to one above.\n * @//param  {Item | String} what        Reference to, or id of the container to delete.\n * @param  {Item} what        Reference to the container to delete.\n * @param  {Boolean} [noRepacking=false]  `true` to prevent  re-packing after setup change.\n * @return {Object}             deleted item\n */\nPackage.prototype.deleteContainer = function( what, noRepacking ){\n  // if( typeof what === \"string\" ){\n  //   what = this.items[what];\n  // }\n  if( what.items === undefined ){\n    throw new RangeError( \"Cannot delete real element\");\n  }\n  var container = what.container;\n  if( what.id == \"root\" || !container ){\n    throw new RangeError( \"Cannot delete root container\");\n  }\n  // cache some stuff;\n  var siblingsList = container.items;\n  // move all items to container above\n  var itemNo = what.items.length;\n  while( itemNo-- ){\n    // XXX do batch move (tomalec)\n    // XXX keep items list in item object\n    this.moveToContainer( what.items[itemNo], container, true);\n  }\n\n  // remove setup\n  var removed = siblingsList.splice( siblingsList.indexOf(what), 1)[0];\n  // remove item\n  delete this.allItems[what.id];\n\n\n  if(!noRepacking){\n    //TODO: repack only applicable ones\n    this.packItems();\n  }\n  return removed;\n};\n/**\n * Create a unique id for a container\n * @param {Object} parent container\n * @return {String}\n */\nPackage.prototype.generatePackageName = function (container) {\n  var i = 0;\n  while (this.allItems[container.id + '_' + i]) {\n    i++;\n  }\n  return container.id + '_' + i;\n};\n/**\n * Create new empty virtual container.\n * @param  {String} id        Id for the container. If empty, a unique id will be generated\n * @//param  {Item | String} [inContainer=\"root\"] Container item or id\n * @param  {Item} [inContainer=root container] Container item\n * @param  {Rectangle} [rectangle]   rectangle setup (width, height, priority)\n * @param  {Boolean} [noRepacking=false] `true` block re-packing items after setup change\n * @return {item}             created container\n */\nPackage.prototype.createNewContainer = function( id, inContainer, rectangle, noRepacking ){\n  // if( typeof inContainer === \"string\" ){\n  //   inContainer = this.items[inContainer];\n  // } else {\n    inContainer = inContainer || this.setup;\n  // }\n  // cache smth\n\n  if (!id) {\n    id = this.generatePackageName(inContainer);\n  }\n\n  var siblings = inContainer.items;\n\n////-----------------\n  var setup = {\n      gutter: 0,\n      items: [],\n      id: id,\n      priority: rectangle ? rectangle.priority : getMinimumPriority(siblings)/2,\n      width: rectangle && rectangle.width || 0,  // consider use of this.defaultTileSetup\n      height: rectangle && rectangle.height || 0 // consider use of this.defaultTileSetup\n  };\n  this.allItems[ id ] = setup;\n  //\n  // XXX: setter?\n  Object.defineProperty(setup, \"container\", { value: inContainer, writable: true });\n\n  siblings.push(setup);\n\n  if(!noRepacking){\n    //TODO: repack only applicable ones\n    this.packItems();\n  }\n  return setup;\n};\n\nPackage.prototype.isInContainer = function (container, item) {\n    var c = item.container;\n\n    while (c) {\n        if (c == container) {\n            return true;\n        }\n\n        c = c.container;\n    }\n\n    return false;\n};\n\n// TODO: export\nscope.Package = Package;\n\n}(window, Packer));\n"]}