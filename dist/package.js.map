{"version":3,"file":"package.js","sources":["../src/package.js"],"names":["scope","Packer","parseSetup","setup","container","items","name","currentContainer","sNo","Object","defineProperty","value","writable","sLen","length","itemSetup","index","getMinimumPriority","arr","min","i","ilen","priority","Package","this","direction","gutter","prototype","packItems","that","packer","sort","sorter","map","rect","Rectangle","width","widthAuto","indexOf","parseFloat","height","heightAuto","add","minHeight","minWidth","reprioritizeItem","item","increase","end","higher","lower","collection","RangeError","sortedIndex","resizeItem","moveToContainer","what","where","noPacking","from","to","splice","push","deleteContainer","noRepacking","siblingsList","itemNo","removed","generatePackageName","createNewContainer","inContainer","rectangle","siblings","window"],"mappings":"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","sourcesContent":["/**\n * Package\n */\n(function( scope, Packer ){\n\"use strict\";\n\n/**\n * Extend JSON setup, with circular references to items' containers.\n * Creates an array of items and virtual containers, \n * that maps to nodes in setup tree.\n * Applies default container name.\n * @param {Object} setup packer setup\n * @param {Item} [container] parent node\n * @param {Object} [items={}] map of items to update\n * @returns {Array} array of updated/created items\n */\nfunction parseSetup( setup, container, items ){\n    items = items || {};\n    var name, currentContainer;\n    if( !container ){\n      name = setup.name = \"root\"\n      container = null;\n    } else {\n      name = setup.name || ( (container && container.name) + \"_\" + sNo );\n      // FIXME i'm ugly\n      setup.name = name;\n    }\n    // create item for current container\n    items[ name ] = currentContainer = setup;\n    Object.defineProperty(setup, \"container\", {value: container, writable: true});\n\n    // create items list\n    for(var sNo = 0, sLen = setup.items.length; sNo < sLen; sNo++) {\n      var itemSetup = setup.items[sNo];\n\n      // walk the tree recursively\n      if(itemSetup.items){\n        // FIXME I'm ugly\n        // create default name\n        if(!itemSetup.name){\n          itemSetup.name = ( currentContainer.name + \"_\" + sNo );\n        }\n        parseSetup( itemSetup, currentContainer, items );\n      } else {\n        // TODO: make index not mandatory (tomalec)\n        items[ itemSetup.index ] = itemSetup;\n        Object.defineProperty(itemSetup, \"container\", {value: currentContainer, writable: true });\n      }\n    }\n    return items;\n}\n /**\n * Returns the minimum value of the priority property from the given array of objects\n * @param {Array<Object>} arr\n * @return {Number} number in range from 0 to 1\n * @TODO DRY\n */\nfunction getMinimumPriority(arr) {\n  var min = 1;\n  for (var i = 0, ilen = arr.length; i < ilen; i++) {\n    if (arr[i].priority < min) {\n      min = arr[i].priority;\n    }\n  }\n  if (min < 0) {\n    min = 0;\n  }\n  return min;\n}\n\n/**\n * [Package description]\n * @param {Object} [setup] packer setup\n * @IDEA remove this.items (tomalec)\n */\nfunction Package( setup ){\n  this.setup = setup || {\n    name: \"root\",\n    direction: \"rightDown\",\n    gutter: 0,\n    items: []\n  };\n  // XXX: this is only used by layer above (pj-srotable-tiles to match with elements)\n  this.items = \n  parseSetup( this.setup );\n\n  // this.reset();\n}\nPackage.prototype.items = null;\nPackage.prototype.setup = null;\n\n\nPackage.prototype.direction = \"rightDown\";\n\n\n/**\n * [packItems description]\n * @param {Object} setup setup of items fo pack, if not give `#setup` will be used\n */\nPackage.prototype.packItems = function packItems( setup ) {\n  setup || (setup = this.setup);\n  var that = this,\n      packer = new Packer(setup);\n\n  //pack rectangles, and calculate container size\n  packer.items = setup.items\n    .sort(this.sorter) // sort- if neded\n    .map(function(itemSetup){\n      // TODO: do it more lightweight\n      var rect = new Rectangle(itemSetup);\n\n      //first calculate rect width because it cannot be auto TODO: fix for downRight mode\n      if( !rect.widthAuto && typeof rect.width == \"string\" && rect.width.indexOf(\"%\") > 0 ){\n        rect.width = ( (setup.width + setup.gutter) * parseFloat(rect.width) /100  - setup.gutter);\n      } else {\n        rect.width = parseFloat( rect.width );\n      }\n      // caluclate relative size\n      // we cannot use calc(xx% - gutter px) as it can be in virtual container which is a sibling\n      if( !rect.heightAuto && typeof rect.height == \"string\" && rect.height.indexOf(\"%\") > 0 ){\n        rect.height = ( (setup.height + setup.gutter) * parseFloat(rect.height) /100 - setup.gutter );\n      } else {\n        rect.height = parseFloat( rect.height );\n      }\n\n      \n      if (itemSetup.items ) { // container\n        // pack its items first, to figureout minSize\n        rect = that.packItems(\n          rect // use caculated width and height\n        );\n\n      }\n\n      // Pack item\n      packer.add(rect);\n\n      return rect;\n  });\n\n  //change Infinity back to real size:\n  packer.height = setup.heightAuto ? packer.minHeight : parseFloat( setup.height );\n  packer.width = setup.widthAuto ? packer.minWidth : parseFloat( setup.width );\n  return packer;\n};\n\n\n/**\n * Change priority of given item\n * @param  {Item | Number | String} itemIndex    item index (the original item index in DOM), container name, or item itself\n * @param  {Boolean} increase  true - increases priority, false - decreases\n * @param  {Boolean} [end=false] true to move to the end\n * @return {juicy-tile-list}        self\n * @TODO write tests\n */\nPackage.prototype.reprioritizeItem =  function( item, increase, end ){\n  var higher, lower, item;\n  // if( typeof item !== 'object'){\n  //   item = this.items[item];\n  // }\n  var itemSetup = item;\n  // use parent items\n  var collection = item.container && item.container.items;\n  // do nothing for root\n  if( !collection ){\n    throw new RangeError( \"Cannot reprioritize root container\");\n    return false;\n  }\n  // do nothing if there is nothing to rearrange\n  if( collection.length < 2){\n    return this;\n  }\n  var sortedIndex = collection.indexOf( itemSetup );\n\n  // move to the end\n  if( end ||\n      increase && (sortedIndex <= 1) ||\n      !increase && (sortedIndex >= collection.length - 2 )\n  ){\n      // top\n      if(increase){\n          // already on top\n          if(itemSetup.priority == 1){\n              return this;\n          }\n          higher = collection[0];\n          // already there, but with different priority\n          if(higher == item){\n              itemSetup.priority = 1;\n              // do not rearrange\n              return this;\n          } else {\n              // move to the middle\n              higher.priority = (collection[1].priority + 1)/2;\n              itemSetup.priority = 1;\n          }\n      } else { // bottom\n          // already at the bottom\n          if(itemSetup.priority == 0){\n              return this;\n          }\n          lower = collection[collection.length -1 ];\n          // already there, but with different priority.\n          if(lower == item){\n              itemSetup.priority = 0;\n              return this;\n          } else {\n              // move to the middle\n              lower.priority = collection[collection.length -2].priority/2;\n              itemSetup.priority = 0;\n          }\n\n      }\n  } else {\n      // top\n      if(increase){\n          higher = collection[sortedIndex-2];\n          lower = collection[sortedIndex-1];\n      } else {\n          higher = collection[sortedIndex+1];\n          lower = collection[sortedIndex+2];\n      }\n      itemSetup.priority = (higher.priority + lower.priority)/2;\n  }\n\n  // TODO only this scope\n  this.packItems( );\n  return this;\n};\n\n/**\n * Resize given item.\n * @param  {SetupItemRef} item   item from list, or item index (the original item index in DOM)\n * @param  {Number} width  number of cells/columns\n * @param  {Number} height number of cells/rows\n * @return {juicy-tile-list}        self\n */\nPackage.prototype.resizeItem = function(item, width, height){\n  // if(typeof item !== 'object'){\n  //     item = this.items[item];\n  // }\n  item.width = width;\n  item.height = height;\n  // re-pack only applicable branch\n  // this.packItems( item.container, item.container.packer );\n  // re-pack everthing\n  this.packItems();\n\n  return this;\n};\n/**\n * \n * @param  {SetupItemRef} what item referrence or element index or container name\n * @param  {SetupItemRef} [where]    Reference to, or name of destination container.    If name given in *string* is not found in existing containers list, new one will be created and wrapped around given item.\n * @param {Boolean} [noPacking=false]\n * @return {[type]}              [description]\n */\nPackage.prototype.moveToContainer = function( what, where, noPacking ){\n  // if( typeof what !== \"object\" ){\n  //   what = this.items[what];\n  // }\n  var from = what.container && what.container.items;\n  // do nothing for root\n  if( !from ){\n    throw new RangeError( \"Cannot move root container\");\n    return false;\n  }\n  var to;\n  // if( typeof where === \"string\" ){\n  //   // container given by key\n  //   where = this.items[where] || \n  //   // or new one\n  //           this.createNewContainer(where, from, what, true);\n  // }\n  to = where.items;\n  // origin == destination\n  if( from == to ){\n    return false;\n  }\n\n  from.splice( from.indexOf(what), 1);\n  what.container = where;\n  to.push(what);\n\n  if(!noPacking){\n    //TODO: repack only applicable ones\n    this.packItems();\n  }\n\n};\n/**\n * Delete virtual container, move items (if any) to one above.\n * @param  {Item | String} what        Reference to, or name of the container to delete.\n * @param  {Boolean} [noRepacking=false]  `true` to prevent  re-packing after setup change.\n * @return {Object}             deleted item\n */\nPackage.prototype.deleteContainer = function( what, noRepacking ){\n  // if( typeof what === \"string\" ){\n  //   what = this.items[what];\n  // }\n  if( what.index ){\n    throw new RangeError( \"Cannot delete real element\");\n  }\n  var container = what.container;\n  if( what.name == \"root\" || !container ){\n    throw new RangeError( \"Cannot delete root container\");\n  }\n  // cache some stuff;\n  var siblingsList = container.items;\n  // move all items to container above\n  var itemNo = what.items.length;\n  while( itemNo-- ){\n    // XXX do batch move (tomalec)\n    // XXX keep items list in item object\n    this.moveToContainer( what.items[itemNo], container, true);\n  }\n\n  // remove setup\n  var removed = siblingsList.splice( siblingsList.indexOf(what), 1)[0];\n  // remove item\n  delete this.items[what.name];\n\n\n  if(!noRepacking){\n    //TODO: repack only applicable ones\n    this.packItems();\n  }\n  return removed;\n};\n/**\n * Create a unique name for a container\n * @param {Object} parent container\n * @return {String}\n */\nPackage.prototype.generatePackageName = function (container) {\n  var i = 0;\n  while (this.items[container.name + '_' + i]) {\n    i++;\n  }\n  return container.name + '_' + i;\n};\n/**\n * Create new empty virtual container.\n * @param  {String} name        Name for the container. If empty, a unique name will be generated\n * @param  {Item | String} [inContainer=\"root\"] Container item\n * @param  {Rectangle} [rectangle]   rectangle setup (width, height, priority)\n * @param  {Boolean} [noRepacking=false] `true` block re-packing items after setup change\n * @return {item}             created container\n */\nPackage.prototype.createNewContainer = function( name, inContainer, rectangle, noRepacking ){\n  // if( typeof inContainer === \"string\" ){\n  //   inContainer = this.items[inContainer];\n  // } else {\n    inContainer = inContainer || this.setup;\n  // }\n  // cache smth\n\n  if (!name) {\n    name = this.generatePackageName(inContainer);\n  }\n\n  // TODO check if name exists\n  var siblings = inContainer.items;\n\n////-----------------\n  var setup = {\n      gutter: 0,\n      items: [],\n      name: name,\n      priority: rectangle ? rectangle.priority : getMinimumPriority(siblings)/2,\n      width: rectangle && rectangle.width || 0,  // consider use of this.defaultTileSetup\n      height: rectangle && rectangle.height || 0 // consider use of this.defaultTileSetup\n  };\n  this.items[ name ] = setup;\n  // \n  // XXX: setter?\n  Object.defineProperty(setup, \"container\", { value: inContainer, writable: true });\n\n  siblings.push(setup);\n\n  if(!noRepacking){\n    //TODO: repack only applicable ones\n    this.packItems();\n  }\n  return setup;\n};\n\n\n// TODO: export\nscope.Package = Package;\n\n}(window, Packer));\n"]}