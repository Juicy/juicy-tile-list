{"version":3,"file":"packer.js","sources":["../src/packer.js"],"names":["scope","Packer","props","prop","this","direction","height","Number","POSITIVE_INFINITY","width","reset","prototype","gutter","minWidth","minHeight","slots","initialSlot","Rectangle","x","y","push","sorter","sorters","rightDown","add","rectangle","si","len","length","slot","canFit","placeAt","placed","revisedSlots","i","newSlots","getSlotsAround","apply","Math","max","cleanRedundant","sort","rectangles","rectNo","currentRect","compareRects","slice","splice","removedCount","compareNo","cLen","compareRect","afterCurrentRect","contains","a","b","downRight","window"],"mappings":"CAIC,SAAUA,GACX,YAaA,SAASC,GAAQC,GACf,IAAM,GAAIC,KAAQD,GAChBE,KAAMD,GAASD,EAAOC,EAEH,cAAlBC,KAAKC,UACND,KAAKE,OAASC,OAAOC,kBAErBJ,KAAKK,MAAQF,OAAOC,kBAEtBJ,KAAKM,QAEPT,EAAOU,UAAUF,MAAQF,OAAOC,kBAChCP,EAAOU,UAAUL,OAASC,OAAOC,kBACjCP,EAAOU,UAAUC,OAAS,EAC1BX,EAAOU,UAAUN,UAAY,YAC7BJ,EAAOU,UAAUE,SAAW,EAC5BZ,EAAOU,UAAUG,UAAY,EAK7Bb,EAAOU,UAAUD,MAAQ,WACvBN,KAAKW,QACL,IAAIC,GAAc,GAAIC,YACpBC,EAAG,EACHC,EAAG,EACHV,MAAOL,KAAKK,MACZH,OAAQF,KAAKE,QAGfF,MAAKW,MAAMK,KAAMJ,GAGjBZ,KAAKiB,OAASC,EAASlB,KAAKC,YAAeiB,EAAQC,WAQrDtB,EAAOU,UAAUa,IAAM,SAAUC,GAE1BA,EAAUhB,MAAQL,KAAKK,QACxBgB,EAAUhB,MAAQL,KAAKK,OAEtBgB,EAAUnB,OAASF,KAAKE,SACzBmB,EAAUnB,OAASF,KAAKE,OAG5B,KAAM,GAAIoB,GAAG,EAAGC,EAAMvB,KAAKW,MAAMa,OAAaD,EAALD,EAAUA,IAAO,CACxD,GAAIG,GAAOzB,KAAKW,MAAMW,EAEtB,IAAKG,EAAKC,OAAQL,GAAc,CAC9BrB,KAAK2B,QAASN,EAAWI,EACzB,QAGJ,MAAOzB,OAWTH,EAAOU,UAAUoB,QAAU,SAAUN,EAAWI,GAM9C,MAJAJ,GAAUP,EAAIW,EAAKX,EACnBO,EAAUN,EAAIU,EAAKV,EAEnBf,KAAK4B,OAAQP,GACNA,GAQTxB,EAAOU,UAAUqB,OAAS,SAAUP,GAC/BrB,KAAKQ,SACNa,EAAUhB,OAAS,EAAIL,KAAKQ,OAC5Ba,EAAUnB,QAAU,EAAIF,KAAKQ,OAC7Ba,EAAUP,GAAKd,KAAKQ,OACpBa,EAAUN,GAAKf,KAAKQ,OAItB,KAAM,GADFqB,MACMC,EAAE,EAAGP,EAAMvB,KAAKW,MAAMa,OAAYD,EAAJO,EAASA,IAAM,CACrD,GAAIL,GAAOzB,KAAKW,MAAMmB,GAClBC,EAAWN,EAAKO,eAAgBX,EAC/BU,GAEHF,EAAab,KAAKiB,MAAOJ,EAAcE,GAGvCF,EAAab,KAAMS,GAGpBzB,KAAKQ,SACNa,EAAUhB,OAAS,EAAIL,KAAKQ,OAC5Ba,EAAUnB,QAAU,EAAIF,KAAKQ,OAC7Ba,EAAUP,GAAKd,KAAKQ,OACpBa,EAAUN,GAAKf,KAAKQ,QAGtBR,KAAKS,SAAWyB,KAAKC,IAAKd,EAAUP,EAAIO,EAAUhB,MAAOL,KAAKS,UAC9DT,KAAKU,UAAYwB,KAAKC,IAAKd,EAAUN,EAAIM,EAAUnB,OAAQF,KAAKU,WAGhEV,KAAKW,MAAQkB,EACbhC,EAAOuC,eAAgBpC,KAAKW,OAC5BX,KAAKW,MAAM0B,KAAMrC,KAAKiB,SAQxBpB,EAAOuC,eAAiB,SAAUE,GAChC,IAAM,GAAIC,GAAO,EAAGhB,EAAMe,EAAWd,OAAiBD,EAATgB,EAAcA,IAAW,CACpE,GAAIC,GAAcF,EAAWC,EAE7B,IAAMC,EAAN,CAIA,GAAIC,GAAeH,EAAWI,MAAM,EAEpCD,GAAaE,OAAQJ,EAAQ,EAG7B,KAAM,GADFK,GAAe,EACTC,EAAU,EAAGC,EAAOL,EAAajB,OAAoBsB,EAAZD,EAAkBA,IAAc,CACjF,GAAIE,GAAcN,EAAaI,GAC3BG,EAAmBT,EAASM,EAAY,EAAI,CAC3CL,GAAYS,SAAUF,KAGzBT,EAAWK,OAAQE,EAAYG,EAAmBJ,EAAc,GAChEA,OAKN,MAAON,GAGT,IAAIpB,IAEFC,UAAW,SAAU+B,EAAGC,GACtB,MAAOD,GAAEnC,EAAIoC,EAAEpC,GAAKmC,EAAEpC,EAAIqC,EAAErC,GAG9BsC,UAAW,SAAUF,EAAGC,GACtB,MAAOD,GAAEpC,EAAIqC,EAAErC,GAAKoC,EAAEnC,EAAIoC,EAAEpC,GAMhCnB,GAAMC,OAASA,GAEbwD","sourcesContent":["/**\n * Packer\n * bin-packing algorithm\n */\n(function( scope ){\n\"use strict\";\n\n/**\n * Packs Rectangles to infinite rectangle (\\infty × \n * infty, width × \\infty, or height × \\infty)\n * @param {Object} [props] packer properties\n * @param {Number} [props.width=0] packer width (in px)\n * @param {Number} [props.height=0] packer height (in px)\n * @param {Number} [props.gutter=0] gutter between items (in px)\n * @param {String} [props.direction=\"rightDown\"] packing direction `\"rightDown\"|\"downRight\"`\n * @TODO write tests for `#gutter` (tomalec)\n * @IDEA make it single dimentional, merge width and hegith into single constraint\n */\nfunction Packer( props /*width, height, direction*/ ){\n  for ( var prop in props ) {\n    this[ prop ] = props[ prop ];\n  }\n  if(this.direction == \"rightDown\"){\n    this.height = Number.POSITIVE_INFINITY;\n  } else {\n    this.width = Number.POSITIVE_INFINITY;\n  }\n  this.reset();\n}\nPacker.prototype.width = Number.POSITIVE_INFINITY;\nPacker.prototype.height = Number.POSITIVE_INFINITY;\nPacker.prototype.gutter = 0;\nPacker.prototype.direction = \"rightDown\";\nPacker.prototype.minWidth = 0;\nPacker.prototype.minHeight = 0;\n\n/**\n * Reset all free slots in packer.\n */\nPacker.prototype.reset = function() {\n  this.slots = [];\n  var initialSlot = new Rectangle({\n    x: 0,\n    y: 0,\n    width: this.width,\n    height: this.height\n  });\n\n  this.slots.push( initialSlot );\n\n  // set sorter\n  this.sorter = sorters[ this.direction ] || sorters.rightDown;\n};\n\n/**\n * Find a slot and place rectanle there\n * @param {Rectanlge} rectangle  to add\n * @returns {Packer} packer itself\n */\nPacker.prototype.add = function( rectangle ) {\n  // trim too big rectangles\n    if(rectangle.width > this.width){\n      rectangle.width = this.width;\n    }\n    if(rectangle.height > this.height){\n      rectangle.height = this.height;\n    }\n\n  for ( var si=0, len = this.slots.length; si < len; si++ ) {\n    var slot = this.slots[si];\n\t//CHANGEME\n    if ( slot.canFit( rectangle ) ) {\n      this.placeAt( rectangle, slot );\n      break;\n    }\n  }\n  return this;\n};\n/** \n * Place element at specyfic slot\n * @param  {Rectangle} rectangle  [description]\n * @param  {Rectangle | Object} slot slot to place, or at least object with position\n * @param  {Number} slot.x\n * @param  {Number} slot.y\n * @return {Rectangle}       placed rectangle\n * @IDEA implement version for placing at given slot (not point), to prevent iterating in #placed\n */\nPacker.prototype.placeAt = function( rectangle, slot ) {\n  // place rectangle in slot\n  rectangle.x = slot.x;\n  rectangle.y = slot.y;\n\n  this.placed( rectangle );\n  return rectangle;\n};\n\n\n/**\n * Update all free slots, for given new `rectangle`.\n * @param  {Rectangle} rectangle being added\n */\nPacker.prototype.placed = function( rectangle ) {\n  if(this.gutter){\n    rectangle.width += 2 * this.gutter;\n    rectangle.height += 2 * this.gutter;\n    rectangle.x -= this.gutter;\n    rectangle.y -= this.gutter;\n  }\n  // update slots\n  var revisedSlots = [];\n  for ( var i=0, len = this.slots.length; i < len; i++ ) {\n    var slot = this.slots[i];\n    var newSlots = slot.getSlotsAround( rectangle );\n    if ( newSlots ) { \n      // slot intersects with rectangle, add all slots around\n      revisedSlots.push.apply( revisedSlots, newSlots );\n    } else { \n      // this slot does not intersect with one to add\n      revisedSlots.push( slot );\n    }\n  }\n  if(this.gutter){\n    rectangle.width -= 2 * this.gutter;\n    rectangle.height -= 2 * this.gutter;\n    rectangle.x += this.gutter;\n    rectangle.y += this.gutter;\n  }\n  // stretch container\n  this.minWidth = Math.max( rectangle.x + rectangle.width, this.minWidth );\n  this.minHeight = Math.max( rectangle.y + rectangle.height, this.minHeight );\n\n  // update slots\n  this.slots = revisedSlots;\n  Packer.cleanRedundant( this.slots );\n  this.slots.sort( this.sorter );\n};\n\n/**\n * Remove redundant rectangle from array of rectangles\n * @param {Array<Rectangle>} rectangles array to clean\n * @returns {Array<Rectangle>} cleaned array\n**/\nPacker.cleanRedundant = function( rectangles ) {\n  for ( var rectNo=0, len = rectangles.length; rectNo < len; rectNo++ ) {\n    var currentRect = rectangles[rectNo];\n    // skip over this rectangle if it was already removed\n    if ( !currentRect ) {\n      continue;\n    }\n    // clone rectangles we're testing\n    var compareRects = rectangles.slice(0);\n    // do not compare with self\n    compareRects.splice( rectNo, 1 );\n    // compare currentRect with others\n    var removedCount = 0;\n    for ( var compareNo=0, cLen = compareRects.length; compareNo < cLen; compareNo++ ) {\n      var compareRect = compareRects[compareNo];\n      var afterCurrentRect = rectNo > compareNo ? 0 : 1;\n      if ( currentRect.contains( compareRect ) ) {\n        // if currentRect contains another,\n        // remove that rectangle from test collection\n        rectangles.splice( compareNo + afterCurrentRect - removedCount, 1 );\n        removedCount++;\n      }\n    }\n  }\n\n  return rectangles;\n};\n\nvar sorters = {\n  // align in horizontal layers RTL\n  rightDown: function( a, b ) {\n    return a.y - b.y || a.x - b.x;\n  },\n  // align in vertical layers UTB\n  downRight: function( a, b ) {\n    return a.x - b.x || a.y - b.y;\n  }\n};\n\n\n// TODO: export\nscope.Packer = Packer;\n\n}(window));"]}