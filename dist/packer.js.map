{"version":3,"file":"packer.js","sources":["../src/packer.js"],"names":["scope","Packer","props","prop","this","direction","height","Number","POSITIVE_INFINITY","width","reset","prototype","gutter","minWidth","minHeight","slots","initialSlot","Rectangle","x","y","push","sorter","sorters","rightDown","add","rectangle","si","len","length","slot","canFit","placeAt","placed","revisedSlots","i","newSlots","getSlotsAround","apply","Math","max","cleanRedundant","sort","rectangles","rectNo","currentRect","compareRects","slice","splice","removedCount","compareNo","cLen","compareRect","afterCurrentRect","contains","a","b","downRight","window"],"mappings":"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","sourcesContent":["/**\r\n * Packer\r\n * bin-packing algorithm\r\n * version: 0.0.9\r\n */\r\n(function( scope ){\r\n\"use strict\";\r\n\r\n/**\r\n * Packs Rectangles to infinite rectangle (\\infty × \r\n * infty, width × \\infty, or height × \\infty)\r\n * @param {Object} [props] packer properties\r\n * @param {Number} [props.width=0] packer width (in px)\r\n * @param {Number} [props.height=0] packer height (in px)\r\n * @param {Number} [props.gutter=0] gutter between items (in px)\r\n * @param {String} [props.direction=\"rightDown\"] packing direction `\"rightDown\"|\"downRight\"`\r\n * @TODO write tests for `#gutter` (tomalec)\r\n * @IDEA make it single dimentional, merge width and hegith into single constraint\r\n */\r\nfunction Packer( props /*width, height, direction*/ ){\r\n  for ( var prop in props ) {\r\n    this[ prop ] = props[ prop ];\r\n  }\r\n  if(this.direction == \"rightDown\"){\r\n    this.height = Number.POSITIVE_INFINITY;\r\n  } else {\r\n    this.width = Number.POSITIVE_INFINITY;\r\n  }\r\n  this.reset();\r\n}\r\nPacker.prototype.width = Number.POSITIVE_INFINITY;\r\nPacker.prototype.height = Number.POSITIVE_INFINITY;\r\nPacker.prototype.gutter = 0;\r\nPacker.prototype.direction = \"rightDown\";\r\nPacker.prototype.minWidth = 0;\r\nPacker.prototype.minHeight = 0;\r\n\r\n/**\r\n * Reset all free slots in packer.\r\n */\r\nPacker.prototype.reset = function() {\r\n  this.slots = [];\r\n  var initialSlot = new Rectangle({\r\n    x: 0,\r\n    y: 0,\r\n    width: this.width,\r\n    height: this.height\r\n  });\r\n\r\n  this.slots.push( initialSlot );\r\n\r\n  // set sorter\r\n  this.sorter = sorters[ this.direction ] || sorters.rightDown;\r\n};\r\n\r\n/**\r\n * Find a slot and place rectanle there\r\n * @param {Rectanlge} rectangle  to add\r\n * @returns {Packer} packer itself\r\n */\r\nPacker.prototype.add = function( rectangle ) {\r\n  // trim too big rectangles\r\n    if(rectangle.width > this.width){\r\n      rectangle.width = this.width;\r\n    }\r\n    if(rectangle.height > this.height){\r\n      rectangle.height = this.height;\r\n    }\r\n\r\n  for ( var si=0, len = this.slots.length; si < len; si++ ) {\r\n    var slot = this.slots[si];\r\n\t//CHANGEME\r\n    if ( slot.canFit( rectangle ) ) {\r\n      this.placeAt( rectangle, slot );\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n/** \r\n * Place element at specyfic slot\r\n * @param  {Rectangle} rectangle  [description]\r\n * @param  {Rectangle | Object} slot slot to place, or at least object with position\r\n * @param  {Number} slot.x\r\n * @param  {Number} slot.y\r\n * @return {Rectangle}       placed rectangle\r\n * @IDEA implement version for placing at given slot (not point), to prevent iterating in #placed\r\n */\r\nPacker.prototype.placeAt = function( rectangle, slot ) {\r\n  // place rectangle in slot\r\n  rectangle.x = slot.x;\r\n  rectangle.y = slot.y;\r\n\r\n  this.placed( rectangle );\r\n  return rectangle;\r\n};\r\n\r\n\r\n/**\r\n * Update all free slots, for given new `rectangle`.\r\n * @param  {Rectangle} rectangle being added\r\n */\r\nPacker.prototype.placed = function( rectangle ) {\r\n  if(this.gutter){\r\n    rectangle.width += 2 * this.gutter;\r\n    rectangle.height += 2 * this.gutter;\r\n    rectangle.x -= this.gutter;\r\n    rectangle.y -= this.gutter;\r\n  }\r\n  // update slots\r\n  var revisedSlots = [];\r\n  for ( var i=0, len = this.slots.length; i < len; i++ ) {\r\n    var slot = this.slots[i];\r\n    var newSlots = slot.getSlotsAround( rectangle );\r\n    if ( newSlots ) { \r\n      // slot intersects with rectangle, add all slots around\r\n      revisedSlots.push.apply( revisedSlots, newSlots );\r\n    } else { \r\n      // this slot does not intersect with one to add\r\n      revisedSlots.push( slot );\r\n    }\r\n  }\r\n  if(this.gutter){\r\n    rectangle.width -= 2 * this.gutter;\r\n    rectangle.height -= 2 * this.gutter;\r\n    rectangle.x += this.gutter;\r\n    rectangle.y += this.gutter;\r\n  }\r\n  // stretch container\r\n  this.minWidth = Math.max( rectangle.x + rectangle.width, this.minWidth );\r\n  this.minHeight = Math.max( rectangle.y + rectangle.height, this.minHeight );\r\n\r\n  // update slots\r\n  this.slots = revisedSlots;\r\n  Packer.cleanRedundant( this.slots );\r\n  this.slots.sort( this.sorter );\r\n};\r\n\r\n/**\r\n * Remove redundant rectangle from array of rectangles\r\n * @param {Array<Rectangle>} rectangles array to clean\r\n * @returns {Array<Rectangle>} cleaned array\r\n**/\r\nPacker.cleanRedundant = function( rectangles ) {\r\n  for ( var rectNo=0, len = rectangles.length; rectNo < len; rectNo++ ) {\r\n    var currentRect = rectangles[rectNo];\r\n    // skip over this rectangle if it was already removed\r\n    if ( !currentRect ) {\r\n      continue;\r\n    }\r\n    // clone rectangles we're testing\r\n    var compareRects = rectangles.slice(0);\r\n    // do not compare with self\r\n    compareRects.splice( rectNo, 1 );\r\n    // compare currentRect with others\r\n    var removedCount = 0;\r\n    for ( var compareNo=0, cLen = compareRects.length; compareNo < cLen; compareNo++ ) {\r\n      var compareRect = compareRects[compareNo];\r\n      var afterCurrentRect = rectNo > compareNo ? 0 : 1;\r\n      if ( currentRect.contains( compareRect ) ) {\r\n        // if currentRect contains another,\r\n        // remove that rectangle from test collection\r\n        rectangles.splice( compareNo + afterCurrentRect - removedCount, 1 );\r\n        removedCount++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return rectangles;\r\n};\r\n\r\nvar sorters = {\r\n  // align in horizontal layers RTL\r\n  rightDown: function( a, b ) {\r\n    return a.y - b.y || a.x - b.x;\r\n  },\r\n  // align in vertical layers UTB\r\n  downRight: function( a, b ) {\r\n    return a.x - b.x || a.y - b.y;\r\n  }\r\n};\r\n\r\n\r\n// TODO: export\r\nscope.Packer = Packer;\r\n\r\n}(window));"]}