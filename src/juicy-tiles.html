<!-- Import Polymer -->
<script src="rectangle.js"></script>
<script src="packer.js"></script>
<script src="package.js"></script>

<!-- Define your custom element -->
<polymer-element name="juicy-tiles" constructor="PJSortableTiles" attributes="setup rowspans colspans layersOrientation">
    <template>
    <style>
        :host {
            display: block;
            padding: 16px;
        }
        #container{
            position: relative;
        }
        polyfill-next-selector { content: ':host #container> *'; }
        #container ::content>* {
            position: absolute;
            -webkit-transition: width 0.5s, height 0.5s, top 0.5s, left 0.5s, -webkit-transform 0.5s;
            transition: width 0.5s, height 0.5s, top 0.5s, left 0.5s, transform 0.5s;
            transition-timing-function: ease-out;
            z-index: 2;
        }
        #container {
          z-index: 0;
        }
    </style>
    <div id="container"><content></content></div>
    </template>
    <script>
    (function( scope ){
      /**
       * For a given element, returns the available width excluding margin, border and padding
       * @param {Element} elem
       * @return {Number}
       */
      function innerWidth(elem) {
        var outerWidth = elem.offsetWidth;
        var computedStyle = window.getComputedStyle(elem, null);
        var borderLeft = parseInt(computedStyle.getPropertyValue('border-left'), 10);
        var borderRight = parseInt(computedStyle.getPropertyValue('border-right'), 10);
        var paddingLeft = parseInt(computedStyle.getPropertyValue('padding-left'), 10);
        var paddingRight = parseInt(computedStyle.getPropertyValue('padding-right'), 10);
        return outerWidth - borderLeft - borderRight - paddingLeft - paddingRight;
      }

      /**
       * For a given element, returns the available height excluding margin, border and padding
       * @param {Element} elem
       * @return {Number}
       */
      function innerHeight(elem) {
        var outerHeight = elem.offsetHeight;
        var computedStyle = window.getComputedStyle(elem, null);
        var borderTop = parseInt(computedStyle.getPropertyValue('border-top'), 10);
        var borderBottom = parseInt(computedStyle.getPropertyValue('border-bottom'), 10);
        var paddingTop = parseInt(computedStyle.getPropertyValue('padding-top'), 10);
        var paddingBottom = parseInt(computedStyle.getPropertyValue('padding-bottom'), 10);
        return outerHeight - borderTop - borderBottom - paddingTop - paddingBottom;
      }

      /**
       * Save JSON tree to the local storage using the provided key
       * @param {String} key
       * @param {Object} value
       */
      function saveJson(key, value) {
        if (key) {
          var str = JSON.stringify(value);
          localStorage.setItem(key, str);
        }
      }

      /**
       * Loads JSON tree from the local storage using the provided key
       * @param {String} key
       * @return {Object}
       */
      function loadJson(key) {
        if (key) {
          var str = localStorage.getItem(key);
          return JSON.parse(str);
        }
      }

        var defaultSetupNode = {
            width: 256,
            height: 128,
            priority: 0
        }
        /**
         * Disregard `<style>`, `<template>` and Text nodes.
         * @param  {NodesList} nodesList nodes list to filter
         * @return {Array}           array of sortable children.
         */
        function filterNodes( nodesList ){
            return nodesList.array()
                        .filter(function filterOutText(child){
                            return !(child instanceof Text) &&
                                    !(child instanceof HTMLLinkElement) &&
                                    !(child instanceof HTMLStyleElement) &&
                                    !(child instanceof HTMLTemplateElement) &&
                                    !(child.nodeName == "PUPPET-MORPHURL") && //ok, this is too much. ideas?
                                    !(child instanceof HTMLScriptElement);
                        });
        }

        /**
         * Modifies setup array with default settings for not mapped elements
         * @param {Array} elements
         * @param {Array} setupItems
         */
        function defaultSetup( elements, setupItems, items ){
            for(var elNo = 0, eLen = elements.length; elNo < eLen; elNo++) {
              var element = elements[elNo];
              if( !items[elNo] ){
                var itemSetup = JSON.parse(JSON.stringify(defaultSetupNode));
                if(setupItems.length == 0) {
                  itemSetup.priority = 0.5;
                }
                else {
                  itemSetup.priority = getMinimumPriority(setupItems) * (1-1/eLen);
                }
                itemSetup.index = elNo;
                Object.defineProperty(itemSetup, "container", {value:items["root"], writable: true})
                setupItems.push(itemSetup);
                items[elNo] = itemSetup;
              }
            }
        }

        /**
         * Returns the minimum value of the priority property from the given array of objects
         * @param {Array<Object>} arr
         * @return {Number} number in range from 0 to 1
         * @TODO DRY
         */
        function getMinimumPriority(arr) {
          var min = 1;
          for (var i = 0, ilen = arr.length; i < ilen; i++) {
            if (arr[i].priority < min) {
              min = arr[i].priority;
            }
          }
          if (min < 0) {
            min = 0;
          }
          return min;
        }
        function workaroundOnResizeEvent(node, fn){
          var parent = node;
          parent = parent.parentNode;
          while( parent && parent.tagName != "BODY" ){
            if(parent.tagName == "JUICY-TILES"){
              parent.addEventListener("juicy-tiles-refresh", fn);
              break;
            }
            parent = parent.parentNode;
          }
        }

        Polymer('juicy-tiles', Platform.mixin( {}, Package.prototype, {
            setup: null,
            // {
            //   direction: "rightDown",
            //   gap: 8,
            //   items: []
            // },
            elements: null,
            // {
            //  index_in_DOM: {element: DOMElement, setup: setupObject, container},..
            //  containerName: {setup: setupObject, items: , packer: packer}        
            items: null,// {}, 

            sorter: function byPriority(itemA, itemB){
                return itemB.priority - itemA.priority;
            },
            createItemsList: function(){
              this.elements = filterNodes(this.children);
              defaultSetup(
                this.elements,
                this.setup.items,
                this.items
              );
            },
            attached: function gridAttached(){
                //ensure any element upgrades have been processed
                //TODO Add mutation observer for window resize, and items change
                this.async(function asyncAttached(){
                    var that = this;

                    this.loadFromStorage();

                    Package.call(this, this.setup);
                    this.createItemsList();
                    this.refresh();

                    if(document.attachEvent){
                      element.detachEvent('onresize', this.refresh.bind(this, null, null));
                    } else {
                      //FIXME: async timeout look ugly (tomalec)
                      //we wait for transition, so innerHeight won't miss the planned size
                      workaroundOnResizeEvent( this, this.async.bind(this, "refresh", [null, null],500+1) );
                    }

                    window.addEventListener('resize', this.refresh.bind(this, null, null), true);

                    var that = this;

                    // Observe changes
                    // TODO: Make it cleaner
                    // create an observer instance
                    var observer = new MutationObserver(function(mutations) {
                      mutations.forEach(function(mutation) {
                        console.log("observation", mutation.type, arguments, mutations);
                        if(mutation.addedNodes){
                            //DRY, performance
                            console.log("something was added")
                            that.createItemsList();
                            that.refresh();
                        }
                      });
                    });
                    // pass in the target node, as well as the observer options
                    observer.observe(this, { childList: true });
                    // end of: Observe changes
                });
            },
            /**
             * Refresh everything
             */
          refresh: function( ) {
              // TODO: support LTR
            if( this.setup.direction != "downRight"){
               this.setup.width = innerWidth(this);
            } else {
              this.setup.height = innerHeight(this);
            }
            this.saveToStorage();
            var packedTree = this.packItems( );
            var container = this.$.container;
            
            function renderTree( node, elements, offsetX, offsetY ){
              var element = elements[ node.name || node.index ] 
                            || container; //TODO: remove it from here, so we could remove renderTree to outer scope
                  elementStyle = element.style;
              offsetX = ( node.x || 0 ) + offsetX; 
              offsetY = ( node.y || 0 ) + offsetY; 
              elementStyle.left = offsetX + "px";
              elementStyle.top = offsetY + "px";
              elementStyle.width = node.width + "px";
              elementStyle.height = node.height + "px";
              if(node.background != undefined) {
                elementStyle.backgroundColor = node.background || "transparent";
              }
              
              if(node.items){
                var childNodeNo = node.items.length;  
                while(childNodeNo--){
                  renderTree( node.items[childNodeNo], elements, offsetX, offsetY);
                }
              }


            }
            renderTree( packedTree, this.elements, 0, 0);
            // trigger event
            this.dispatchEvent( new CustomEvent("juicy-tiles-refresh") );
          },
          saveToStorage: function() {
            saveJson(this.id, this.setup);
          },

          loadFromStorage: function() {
            var loadedSetup = loadJson(this.id);
            if(loadedSetup) {
              this.setup = loadedSetup;
            }
          }
         }) 
        );
    }());
    </script>

</polymer-element>
