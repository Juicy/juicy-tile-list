<!-- Import Polymer -->
<script src="rectangle.js"></script>
<script src="package.js"></script>
<link rel="import" href="pj-sortable-tiles-editor.html">
<link rel="import" href="element-selector.html">

<!-- Define your custom element -->
<polymer-element name="pj-sortable-tiles" attributes="priorities rowspans colspans layersOrientation">
    <template>
    <style>
        :host {
            display: block;
            padding: 16px;
        }
        #container{
            position: relative;
        }
        polyfill-next-selector { content: ':host #container> *'; }
        #container ::content>* {
            position: absolute;
            -webkit-transition:width 1s, height 1s, top 1s, left 1s, -webkit-transform 1s;
            transition:width 1s, height 1s, top 1s, left 1s, transform 1s;
        }
    </style>
    <div id="container"><content></content></div>
    <pj-sortable-tiles-editor gap="{{gap}}" editedItem="{{editedItem}}" editedItemIndex="{{editedItemIndex}}"></pj-sortable-tiles-editor>
    <element-selector id="elementSelector"></element-selector>
    </template>
    <script>
    (function( scope ){
      /**
       * For a given element, returns the available width excluding margin, border and padding
       * @param {Element} elem
       * @return {Number}
       */
      function innerWidth(elem) {
        var outerWidth = elem.offsetWidth;
        var computedStyle = window.getComputedStyle(elem, null);
        var borderLeft = parseInt(computedStyle.getPropertyValue('border-left'), 10);
        var borderRight = parseInt(computedStyle.getPropertyValue('border-right'), 10);
        var paddingLeft = parseInt(computedStyle.getPropertyValue('padding-left'), 10);
        var paddingRight = parseInt(computedStyle.getPropertyValue('padding-right'), 10);
        return outerWidth - borderLeft - borderRight - paddingLeft - paddingRight;
      }

      /**
       * For a given element, returns the available height excluding margin, border and padding
       * @param {Element} elem
       * @return {Number}
       */
      function innerHeight(elem) {
        var outerHeight = elem.offsetHeight;
        var computedStyle = window.getComputedStyle(elem, null);
        var borderTop = parseInt(computedStyle.getPropertyValue('border-top'), 10);
        var borderBottom = parseInt(computedStyle.getPropertyValue('border-bottom'), 10);
        var paddingTop = parseInt(computedStyle.getPropertyValue('padding-top'), 10);
        var paddingBottom = parseInt(computedStyle.getPropertyValue('padding-bottom'), 10);
        return outerHeight - borderTop - borderBottom - paddingTop - paddingBottom;
      }

      /**
       * Counts index of element within its parent
       * @see http://jsperf.com/sibling-index/10
       * @param {Element} elem
       * @return {Number}
       */
      function elementIndex (elem) {
        var i = 0;
        while (elem = elem.previousElementSibling) {
          if(!(elem instanceof HTMLTemplateElement)) {
            ++i
          }
        }
        return i;
      };

      /**
       * Save JSON tree to the local storage using the provided key
       * @param {String} key
       * @param {Object} value
       */
      function saveJson(key, value) {
        if (key) {
          var str = JSON.stringify(value);
          localStorage.setItem(key, str);
        }
      }

      /**
       * Loads JSON tree from the local storage using the provided key
       * @param {String} key
       * @return {Object}
       */
      function loadJson(key) {
        if (key) {
          var str = localStorage.getItem(key);
          return JSON.parse(str);
        }
      }

        var defaultSetupNode = {
            width: 200,
            height: 100,
            priority: 0
        }
        /**
         * Disregard `<style>`, `<template>` and Text nodes.
         * @param  {NodesList} nodesList nodes list to filter
         * @return {Array}           array of sortable items.
         */
        function filterNodes( nodesList ){
            return nodesList.array()
                        .filter(function filterOutText(child){
                            return !(child instanceof Text) &&
                                    !(child instanceof HTMLTemplateElement) &&
                                    !(child instanceof HTMLScriptElement);
                        });
        }

        /**
         * Modifies setup array with default settings for not mapped elements
         * @param {Array} elements
         * @param {Array} setup
         */
        function createItemsList( elements, setup ){
            for(var i = 0, ilen = elements.length - setup.length; i < ilen; i++) {
              var item = JSON.parse(JSON.stringify(defaultSetupNode));
              if(setup.length == 0) {
                item.priority = 0.5;
              }
              else {
                item.priority = getMinimumPriority(setup) - 0.01
              }
              setup.push(item);
            }
        }

        /**
         * Returns the minimum value of the priority property from the given array of objects
         * @param {Array<Object>} arr
         * @return {Number} number in range from 0 to 1
         */
        function getMinimumPriority(arr) {
          var min = 1;
          for (var i = 0, ilen = arr.length; i < ilen; i++) {
            if (arr[i].priority < min) {
              min = arr[i].priority;
            }
          }
          if (min < 0) {
            min = 0;
          }
          return min;
        }

        Polymer('pj-sortable-tiles', {
            priorities:[],
            items: null,
            gap: 8,
            maxX:0,
            maxY:0,
            layersOrientation: "horizontal",
            editedItem: null,
            editedItemIndex: 0,
            sorter: function byPriority(itemA, itemB){
                return itemB.rect.priority - itemA.rect.priority;
            },
            package: null,
            createItemsList: function(){
              this.items = filterNodes(this.children);
              createItemsList(
                this.items,
                this.priorities
              );
            },
            attached: function gridAttached(){
                //ensure any element upgrades have been processed
                //TODO Add mutation observer for window resize, and items change
                this.async(function asyncAttached(){
                    var that = this;

                    this.loadFromStorage();

                    // debugger;
                    this.createItemsList();
                    // TODO: support LTR
                        // debugger
                    this.package = new Package(
                            this.layersOrientation !== "vertical" ?
                                {
                                    width: innerWidth(this),
                                    height: Number.POSITIVE_INFINITY,
                                    direction: "rightDown"
                                } : {
                                    width: Number.POSITIVE_INFINITY,
                                    height: innerHeight(this),
                                    direction: "downRight"
                                }
                    );

                    this.saveToStorage();
                    this.packItems( this.getSortedCollection() );

                    var refresh = function() {
                      // console.log(that.package.width, that.clientWidth)
                      // debugger
                      if( that.layersOrientation !== "vertical"){
                        that.package.width = that.clientWidth;
                      } else {
                        that.package.height = that.clientHeight;
                      }
                      that.saveToStorage();
                      that.package.reset();
                      that.packItems( that.getSortedCollection() );
                    }

                    var highlightItem = function (elem) {
                        if (elem != that && elem != that.$.container) {
                            while (elem.parentNode != that.$.container && elem.parentNode != that) {
                                elem = elem.parentNode;
                            }
                            // debugger
                            that.editedItemIndex = elementIndex(elem);
                            if(that.editedItem !== that.priorities[that.editedItemIndex]) {
                              that.editedItem = that.priorities[that.editedItemIndex];
                              that.$.elementSelector.show(elem);
                            }
                        }
                    }

                    var lastTarget;
                    window.addEventListener('keydown', function (ev) {
                      if(lastTarget && (ev.ctrlKey || ev.metaKey)) { //meta is Mac command button
                        highlightItem(lastTarget);
                      }
                    });
                    this.addEventListener('mouseover', function (ev) {
                      if(ev.ctrlKey || ev.metaKey) { //meta is Mac command button
                        highlightItem(ev.target);
                        lastTarget = null;
                      }
                      else {
                        lastTarget = ev.target;
                      }
                    });

                    this.addEventListener('pj-sortable-tiles-editor-close', function () {
                      that.editedItem = null;
                      that.$.elementSelector.hide();
                    });

                    this.addEventListener('pj-sortable-tiles-refresh', refresh, true);

                    window.addEventListener('resize', refresh, true);var that = this;

                    // Observe changes
                    // TODO: Make it cleaner
                    // create an observer instance
                    var observer = new MutationObserver(function(mutations) {
                      mutations.forEach(function(mutation) {
                        console.log("observation", mutation.type, arguments, mutations);
                        if(mutation.addedNodes){
                            // debugger;
                            //DRY, performance
                            console.log("something was added")
                            that.createItemsList();
                            that.saveToStorage();
                            that.package.reset();
                            that.packItems( that.getSortedCollection() );
                        }
                      });
                    });
                    // pass in the target node, as well as the observer options
                    observer.observe(this, { childList: true });
                    // end of: Observe changes
                });
            },

            stretchContainer: function( rectangle ) {
              this.maxX = Math.max( rectangle.x + rectangle.width, this.maxX );
              this.maxY = Math.max( rectangle.y + rectangle.height, this.maxY );
            },
            /**
             * Resize given item.
             * @param  {Object | Number} item   item from list, or item index (the original item index in DOM)
             * @param  {Number} width  number of cells/columns
             * @param  {Number} height number of cells/rows
             * @return {pj-sortable-tiles}        self
             */
            resizeItem: function(item, width, height){
                if(typeof item == 'number'){
                    item = this.items[item];
                }
                item.rect.width = width;
                item.rect.height = height;
                this.saveToStorage();
                this.package.reset();
                this.packItems( this.getSortedCollection() );
                return this;
            },

            /**
             * Returns the collection of DOM elements and their setup sorted on the priority property
             * @return {Array}
             */
            getSortedCollection: function() {
              var that = this;
              var collection = this.items.map(function (item, index) {
                return {
                  element: item,
                  index: index,
                  rect: that.priorities[index]
                }
              });
              collection.sort(that.sorter);
              return collection;
            },

            /**
             * Change priority of given item
             * @param  {Number} itemIndex    item index (the original item index in DOM)
             * @param  {Boolean} increase  true - increases priority, false - decreases
             * @param  {Boolean} [end=false] true to move to the end
             * @return {pj-sortable-tiles}        self
             * @TODO write tests
             */
            reprioritizeItem: function(itemIndex, increase, end){
                var higher, lower, item;
                // do nothing if there is nothing to rearrange
                if( this.items.length < 2){
                  return this;
                }

                // TODO: why do we sort it twice? and call it always before #packItems?
                var collection = this.getSortedCollection();

                for(var i= 0, ilen=collection.length; i<ilen;i++) {
                  if(collection[i].index == itemIndex) {
                    var sortedIndex = i;
                    var item = collection[i];
                  }
                }

                // move to the end
                // debugger
                if( end ||
                    increase && (sortedIndex <= 1) ||
                    !increase && (sortedIndex >= this.items.length - 2 )
                ){
                    // top
                    if(increase){
                        // already on top
                        if(item.rect.priority == 1){
                            return this;
                        }
                        higher = collection[0];
                        // already there, but with different priority
                        if(higher == item){
                            item.rect.priority = 1;
                            // do not rearrange
                            return this;
                        } else {
                            // move to the middle
                            higher.rect.priority = (collection[1].rect.priority + 1)/2;
                            item.rect.priority = 1;
                        }
                    } else { // bottom
                        // already at the bottom
                        if(item.rect.priority == 0){
                            return this;
                        }
                        lower = collection[collection.length -1 ];
                        // already there, but with different priority.
                        if(lower == item){
                            item.rect.priority = 0;
                            return this;
                        } else {
                            // move to the middle
                            lower.rect.priority = collection[collection.length -2].rect.priority/2;
                            item.rect.priority = 0;
                        }

                    }
                } else {
                    // top
                    if(increase){
                        higher = collection[sortedIndex-2];
                        lower = collection[sortedIndex-1];
                    } else {
                        higher = collection[sortedIndex+1];
                        lower = collection[sortedIndex+2];
                    }
                    item.rect.priority = (higher.rect.priority + lower.rect.priority)/2;
                }

                this.saveToStorage();
                this.package.reset();
                // TODO: why do we sort it twice? and call it always before #packItems?
                this.packItems( collection.sort(this.sorter) );
                return this;
            },

            /**
             * [packItems description]
             * @param {Array} collection
             */
            packItems: function(collection){
                var self = this;
                if(!this.originalHeights) {
                  this.originalHeights = [];
                }

                //pack rectangles, and calculate container size
                collection.forEach(function(item, index){
                    // TODO: do it more lightweight
                    var element = item.element;
                    var rect = new Rectangle(item.rect);
                    var elStyle = element.style;
                    if(typeof self.originalHeights[index] === 'undefined') {
                      self.originalHeights.push(element.clientHeight);
                    }
                    if(rect.height == "auto") {
                      rect.height = self.originalHeights[index];
                      elStyle.overflowY = "visible";
                    }
                    else {
                      elStyle.overflowY = "auto";
                    }
                    rect.width += self.gap;
                    rect.height += self.gap;

              
                    self.package.add(rect);

                    self.stretchContainer(rect);

                    elStyle.top = rect.y + self.gap + "px";
                    elStyle.left = rect.x + self.gap + "px";
                    elStyle.width = item.rect.width + "px";
                    elStyle.height = item.rect.height + "px";
                });

                if( self.layersOrientation !== "vertical"){
                    self.$.container.style.height = self.maxY + "px";
                } else {
                    self.$.container.style.width = self.maxX + "px";
                }

            },

            saveToStorage: function() {
              saveJson(this.id, {gap: this.gap, priorities: this.priorities});
            },

            loadFromStorage: function() {
              var loaded = loadJson(this.id);
              if(loaded && loaded.priorities) {
                this.gap = loaded.gap;
                this.priorities = loaded.priorities;
              }
            }
        });
    }());
    </script>

</polymer-element>
