<!-- Import Polymer -->
<script src="rectangle.js"></script>
<script src="package.js"></script>

<!-- Define your custom element -->
<polymer-element name="pj-sortable-tiles" attributes="priorities rowspans colspans cellWidth cellHeight">
    <template>
    <style>
        :host {
            display: block;
            position: relative;
        }
        polyfill-next-selector { content: ':host > *'; }
        ::content>* {
            position: absolute;
            -webkit-transition:width 1s, height 1s, top 1s, left 1s, -webkit-transform 1s;
            transition:width 1s, height 1s, top 1s, left 1s, transform 1s;
        }
    </style>
    <content></content>
    </template>
    <script>
        /**
         * Disregard `<style>`, `<template>` and Text nodes.
         * @param  {NodesList} nodesList nodes list to filter
         * @return {Array}           array of sortable items.
         */
        function filterNodes( nodesList ){
            return nodesList.array()
                        .filter(function filterOutText(child){
                            return !(child instanceof Text) &&
                                    !(child instanceof HTMLTemplateElement) &&
                                    !(child instanceof HTMLScriptElement);
                        });
        }
        /**
         * [createItemsList description]
         * @param  {Array<Element>} elements [description]
         * @return {[type]}          [description]
         */
        function createItemsList( elements, setup, cellWidth, cellHeight ){
            return elements.map(function(element, index){
                // TODO: do it more lightweight
                var rect = new Rectangle({
                        width: setup[index].width * cellWidth,
                        height: setup[index].height * cellHeight,
                        //TODO: it looks a bit hacky
                        priority: setup[index].priority
                    }); 
                return {
                    element: element,
                    rect: rect
                }
            })

        }
        Polymer('pj-sortable-tiles', {
            priorities:[],
            items: null,
            cellHeight: 50,
            cellWidth: 100,
            direction: "downwardLeftToRight",
            sorter: function byPriority(itemA, itemB){
                return itemB.rect.priority - itemA.rect.priority;
            },
            package: null,
            created: function (){
                // this.style.display = "block";
                // this.style.position = "relative";
                // debugging:
                // debugger
                // globMe = this;
            },
            attached: function gridAttached(){
                //ensure any element upgrades have been processed
                this.async(function asyncAttached(){
                    var self = this;

                    // debugger;
                    this.items = createItemsList( 
                            filterNodes( this.children ),
                                this.priorities,
                                this.cellWidth,
                                this.cellHeight
                            )
                            .sort( this.sorter );

                    this.package = new Package({
                        width: this.clientWidth, 
                        height: this.clientHeight,
                        direction: this.direction
                    });
                    
                    this.packItems( this.items, this.priorities );

                    // Observe changes
                    // TODO: Make it cleaner
                    // create an observer instance
                    var observer = new MutationObserver(function(mutations) {
                      mutations.forEach(function(mutation) {
                        console.log("observation", mutation.type, arguments, mutations);
                        if(mutation.addedNodes){
                            // debugger;
                            console.log("something was added")
                        }
                      });
                    });
                    // pass in the target node, as well as the observer options
                    observer.observe(this, { childList: true });
                    // end of: Observe changes
                });
            },
            /**
             * Resize given item.
             * @param  {Object | Number} item   item from list, or item index (note that items list is sorted by priority)
             * @param  {Number} width  number of cells/columns
             * @param  {Number} height number of cells/rows
             * @return {pj-sortable-tiles}        self
             */
            resizeItem: function(item, width, height){
                if(typeof item == 'number'){
                    item = this.items[item];
                }
                item.rect.width = width * this.cellWidth;
                item.rect.height = height * this.cellHeight;
                this.items.sort( this.sorter ) ;
                this.package.reset();
                this.packItems( this.items );
                return this;
            },

            /**
             * Change priority of given item
             * @param  {Number} itemIndex    item index (note that items list is sorted by priority)
             * @param  {Boolean} increase  true - increases priority, false - decreases
             * @param  {Boolean} [end=false] true to move to the end
             * @return {pj-sortable-tiles}        self
             * @TODO write tests
             */
            reprioritizeItem: function(itemIndex, increase, end){
                var higher, lower, item;
                // do nothing if there is nothing to rearrange
                if( this.items.length < 2){
                    return this;
                }
                //use indexes as input
                // if(typeof item == 'number'){
                    item = this.items[itemIndex];
                // }
                // move to the end
                debugger
                if( end || 
                    increase && (itemIndex == 1) ||
                    !increase && (itemIndex == this.items.length - 2 ) 
                ){
                    // top
                    if(increase){
                        // already on top
                        if(item.rect.priority == 1){
                            return this;
                        }
                        higher = this.items[0];
                        // already there, but with different priority
                        if(higher == item){
                            item.rect.priority = 1;
                            // do not rearrange
                            return this;
                        } else {
                            // move to the middle
                            higher.rect.priority = (this.items[1].rect.priority + 1)/2;
                            item.rect.priority = 1;
                        }
                    } else { // bottom                        
                        // already at the bottom
                        if(item.rect.priority == 0){
                            return this;
                        }
                        lower = this.items[this.items.length -1 ];
                        // already there, but with different priority.
                        if(lower == item){
                            item.rect.priority = 0;
                            return this;
                        } else {
                            // move to the middle
                            lower.rect.priority = this.items[this.items.length -2].rect.priority/2;
                            item.rect.priority = 0;
                        }

                    }
                } else {
                    // top
                    if(increase){
                        higher = this.items[itemIndex-2];
                        lower = this.items[itemIndex-1];
                    } else { 
                        higher = this.items[itemIndex+1];
                        lower = this.items[itemIndex+2];
                    }
                    item.rect.priority = (higher.rect.priority + lower.rect.priority)/2;
                }


                this.items.sort( this.sorter ) ;
                this.package.reset();
                this.packItems( this.items );
                return this;
            },

            /**
             * [packItems description]
             * @param  {Array<Object>} collection array of elements
             * @return {Array}            [description]
             */
            packItems: function( collection ){
                var self = this;
                return collection.map(function(item, index){
                    // TODO: do it more lightweight
                    var element = item.element;
                    var rect = item.rect;
                    self.package.add(rect);
                    //TODO: consider repaints optimization
                    var elStyle = element.style;
                    elStyle.top = rect.y + "px";
                    elStyle.left = rect.x + "px";
                    elStyle.width = rect.width + "px";
                    elStyle.height = rect.height + "px";
                    return {
                        element: element,
                        rect: rect
                    }
                })
            }
        });
    </script>

</polymer-element>
